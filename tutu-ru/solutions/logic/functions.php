<?php
/**
 * Created by PhpStorm.
 * User: Rolland
 * Date: 21.02.2019
 * Time: 11:05
 */

/**
 * функция определяет каких камней по сколько взять, чтобы набрать максимум стоимости, в случае, если можно брать толкьо по одному
 * и также отдает максимальную сумму, как было сказано в условии задачи.
 *
 * @param int $maxMass
 * @param array $stoneTypes
 *
 * @return array
 */
function chooseOnlyOneByEveryType($maxMass, $stoneTypes)
{
    // важно, т.к. значения входных данных передаются не по ссылкам, можно их использовать в алгоритме и модифицировать. Иначе - надо делать копии
    $res = [
        'sum' => 0,
        'weight' => 0,
        'takenStones' => []
    ];
    // первым делом сортируем камни по уменьшению цены, тут нет смысла размышлять - берем самые дорогие сколько влезет
    uasort($stoneTypes, function ($stoneA, $stoneB) {
        return $stoneB['p'] <=> $stoneA['p'];
    });
    //
    foreach ($stoneTypes as $stoneType) {
        // проверить, что место еще осталось
        if ($maxMass < $stoneType['m']) {
            break;
        }
        $res['sum'] += $stoneType['p'];
        $res['weight'] += $stoneType['m'];
        $stoneType['count'] = 1;
        $res['takenStones'][] = $stoneType;
        $maxMass -= $stoneType['m'];
    }
    return $res;
}


/**
 * функция определяет каких камней по сколько взять, чтобы набрать максимум стоимости, в случае, если можно брать сколько угодно разного
 * и также отдает максимальную сумму, как было сказано в условии задачи.
 * .... иии, даа, это же "любимая" задача о рюкзаке, только упрощенная, ведь пары вес/стоимость повторяются в неограниченом количестве ))
 *
 * @param int $maxMass
 * @param array $stoneTypes
 *
 * @return array
 */
function chooseMaxPricedDumb($maxMass, $stoneTypes)
{
    // важно, т.к. значения входных данных передаются не по ссылкам, можно их использовать в алгоритме и модифицировать. Иначе - надо делать копии
    $res = [
        'sum' => 0,
        'mass' => 0,
        'takenStones' => []
    ];
    // алгоритм раз, простейший перебор. Терпит пока рюкзак небольшой, а камни исчисляются не миллиграммами
    /*
    для этого алгоритма полезно, если камни отсортированы по увеличению удельной стоимости
    в таком случае, как правило, сумма сразу берется максимальной, и в ходе переборок иногда поднимается
    а если наоборот, то перезаписывание $res происходит почти на каждой итерации
    */
    uasort($stoneTypes, function ($stoneA, $stoneB) {
        return ($stoneA['p'] / $stoneA['m']) <=> ($stoneB['p'] / $stoneB['m']);
    });
    // выдернем камни в переменные, чтобы проще читать было
    $stone1 = current($stoneTypes);
    $stone2 = next($stoneTypes);
    // возьмем 0 камней $stone1 и сколько влезет $stone2, посчитаем сумму, запишем
    // возьмем 1 камень $stone1 и сколько влезет $stone2 , опять посчитаем, сравним с прошлой
    // и так, пока   рюкзак не окажется забитым исключительно $stone1
    for ($q1 = 0; ($mass1 = $q1 * $stone1['m']) <= $maxMass; $q1++) {
        $q2 = floor(($maxMass - $mass1) / $stone2['m']);
        // если полученния цена больше, чем последняя найденная, то заполняем результат
        $price = $q1 * $stone1['p'] + $q2 * $stone2['p'];
        if ($price > $res['sum']) {
            $res['sum'] = $price;
            $res['mass'] = $q1 * $stone1['m'] + $q2 * $stone2['m'];
            $res['takenStones'] = [
                array_merge($stone1, ['count' => $q1]),
                array_merge($stone2, ['count' => $q2]),
            ];
        }
    }
    return $res;
}